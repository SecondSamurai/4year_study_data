
                            Лабораторная работа №6

                         ОБРАБОТКА СИМВОЛЬНЫХ ДАННЫХ.

Цель:
  Получение навыков обработки символьной информации, текстов с использованием
  стандартных функций языка С, а также с помощью своих собственных функций.

Общие замечания:

  Символы и строки
   -каждому символу соответствует число - код символа;
   -в С++ строка - это массив символов;
   -последним символом строки обязательно должен быть нуль-символ, код которого
    равен 0, и который в тексте программы изображается так: \0;
   -сообщения или подсказки, используемые в программе, удобно представлять как
    массив указателей на строки и инициализировать массив, задать сообщения в
    инструкции объявления массива:

     char *mes[] ={"Сообщение 1","Сообщение 2",...,"Сообщение"};

   -если вводимая во время работы программы строка содержит пробелы, то
    функция scanf вводит только часть строки до первого пробела, а функция
    gets - всю строку, в том числе и соответствующий клавише <Enter> символ \n.



  Функции преобразования:

   -atof <stdlib.h>
      Синтаксис:
       double atof(const char* s);

      Возвращает дробное число, значение которого передано функции в качестве
      аргумента. Функция обрабатывает строку до тех пор, пока символы строки
      являются допустимыми. Строка может быть значением числа как в формате
      с плавающей точкой, так и в экспоненциальном формате.


   -atoi, atol <stdlib.h>
      Синтаксис:
       int atoi(const char* s);
       long atol(const char* s);

      Возвращает целое соответствующего типа, изображение которого передано
      функции в качестве аргумента. Функция обрабатывает символы строки до
      тех пор, пока не встретит символ, не являющийся десятичной цифрой.


   -gcvt <stdlib.h>
      Синтаксис:
       char *gcvt (double значение, int цифр, char* строка);

      Преобразует дробное число в строку. При преобразовании делается попытка
      получить указанное количество значащих цифр, а если это сделать
      невозможно, то число изображается в форме с плавающей точкой.


   -itoa, ltoa, ultoa <stdlib.h>
      Синтаксис:
       char* itoa (int значение, char* строка, int основание);
       char* ltoa (long значение, char* строка, int основание);
       char* ultoa (unsigned long значение, char* строка, int основание);

      Соответственно преобразует целое, длинное целое и длинное беззнаковое
      целое в строку. Число изображается в указанной при вызове функции
      системе счисления.
      Строка - указатель на строку, куда будет помещено изображение числа.
      Основание - задает основание системы счисления (от 2 до 36).
      Максимальная длинна строки, формируемой функцией itoa, - 17 байт,
      функциями ltoa и ultoa - 33 байта.


   -sprintf <stdio.h>
      Синтаксис:
       int sprintf (char *строка, const char* формат, список_переменных);

      Выполняет форматированный вывод в строку.
      Список_переменных - разделенные запятыми имена переменных, задает
      переменные, значения которых должны быть выведены. Параметр формат
      задает способ отображения значений переменных.
      Действие функции sprintf аналогично действию функции printf, но вывод
      выполняется в строку-буфер, а не на экран.



  Функции работы со строками:

   -strcat <string.h>
      Синтаксис:
       char *strcat(char* строка1, const char* строка2)

      Объединяет строки строка1 и строка2 и записывает результат в строку
      строка1.


   -strcpy <string.h>
      Синтаксис:
       char *strcpy(char* строка1, const char* строка2)

      Копирует строку строка1 в строку строка2.


   -strlen <string.h>
      Синтаксис:
       int strlen(const char* строка)

      Возвращает длину строки. Нулевой символ не учитывается.


   -strcmp <string.h>
      Синтаксис:
       int strcmp(const char* строка1, const char* строка2)

      Сравнивает строки строка1 и строка2. Возвращает 0, если строки равны,
      число меньше нуля, если строка1 < строка2 и число больше нуля, если
      строка1 > строка2.


   -strlwr <string.h>
      Синтаксис:
       char* strlwr(char* строка)

      Преобразует строчные символы строки в прописные (обрабатывает только
      буквы латинского алфавита).


   -strupr <string.h>
      Синтаксис:
       char* strupr(char* строка)

      Преобразует прописные символы строки в строчные (обрабатывает только
      буквы латинского алфавита).


   -strset <string.h>
      Синтаксис:
       char* strset(char* строка, char символ)

      Заполняет строку указанным при вызове функции символом.


   -strchr <string.h>
      Синтаксис:
       char* strchr(const char* строка, int символ)

      Выполняет поиск символа в строке и возвращает указатель на первый
      найденный символ или, если символ не найден, NULL.


C++. Функции для работы с String (AnsiString)

* При объявлении переменные типа AnsiString инициализируются пустыми строками.
* Для AnsiString определены операции отношения ==, !=, >, <, >=, <=. Сравнение производится с учетом регистра.
* Номера позиций символов строки начинается с 1.
ФункцияОписаниеInsertInsert(const AnsiString& str, int ind)
Вставляет в строку подстроку str, начиная с индекса indPosPos(const AnsiString& subStr) const
Возвращает индекс первого символа первого вхождения subStr в строке. Индексы начинаются с 1. Если subStr не содержится в встроке, возвращается 0. Не поддерживает многобайтные символыIsEmptyВозвращает true, если строка пустаяDeleteDelete(int ind, int count)
Удаляет из строки, начиная с позиции ind символы в количестве countLengthВозвращает длину строки (количество символов в строке)LowerCaseВозвращает строку, в которой все символы приведены к нижнему регистру. Не изменяет исходную строкуUpperCaseВозвращает строку, в которой все символы приведены к верхнему регистру. Не изменяет исходную строкуSubString SubString(int ind, int count)
Возвращает подстроку, начинающуюся с символа в позиции ind и содержащую count символовSetLengthSetLength(int newLen)
Обрезает строку до newLen символов. Если исходная строка короче, то она не увеличиваетсяToDoubleПреобразует строку в число с плавающей запятой. Если строка не соответствует формату числа с плавающей запятой, генерируется исключениеTolntПреобразует строку в целое число. Если строка не соответствует формату целого числа, генерируется исключениеTrimВозвращает строку, соответствующую исходной, но без пробельных символов до и после значащих символовTrimLeftВозвращает строку, соответствующую исходной, но без начальных пробельных символовTrimRightВозвращает строку, соответствующую исходной, но без заключительных пробельных символовc_strВозвращает указатель на строку с нулевым символом в конце char*, содержащую те же символы, что в AnsiStringIsDelimiterIsDelimiter(const AnsiString& delimiters, int ind) const
Возвращает true, если символ с индексом ind является одним из разделителей, указанных в строке delimiters


Задания:

--------------------------------------------------------------------------------
Вариант 1
  Ввести предложение, слова в котором разделены пробелами и запятыми.
  Распечатать это предложение, удалив из него те слова, которые встретились
  там более одного раза.

--------------------------------------------------------------------------------
Вариант 2
  Написать и протестировать функцию DELETE(s1, s2), которая удаляет из строки
  s1 все символы, встречающиеся в строке s2.

--------------------------------------------------------------------------------
Вариант 3
  Даны две символьные строки, состоящие только из цифр (длина каждой - более
  10 символов). Считая, что в этих строках находятся очень длинные целые числа,
  сформировать третью строку - сумму этих чисел.

--------------------------------------------------------------------------------
Вариант 4
  Дан произвольный текст. Отредактировать текст так, чтобы:
   а) между словами был ровно один пробел;
   б) предложения в тексте разделялись ровно двумя пробелами.

--------------------------------------------------------------------------------
Вариант 5
  Написать и протестировать функцию ESCAPE(str1, str2), которая при копировании
  текста из str1 в str2 преобразует литеры "новая строка" и "табуляция" в
  видимые последовательности литер \n и \t. Сделать также функцию, выполняющую
  обратное преобразование.

--------------------------------------------------------------------------------
Вариант 6
  Ввести два предложения и распечатать самые длинные слова, общие для этих
  предложений. Если нужных слов нет - сообщить об этом.

--------------------------------------------------------------------------------
Вариант 7
  Произвести выравнивание по правому краю введенного текста, для чего к каждой
  строке применить функцию WIDE(str, k), которая равномерно вставляет пробелы
  между словами так, чтобы длина строки str стала равной k.
  (Величина k должна быть больше длины самой длинной строки текста).

--------------------------------------------------------------------------------
Вариант 8
  Ввести строку, состоящую только из цифр и букв. Распечатать те группы цифр,
  в которых цифра 7 встречается не более двух раз.
  (Группа цифр - это последовательность цифр, обрамленная буквами).

--------------------------------------------------------------------------------
Вариант 9
  Распечатать те пары слов, расстояние между которыми наименьшее.
  (Расстояние между словами - это количество позиций, в которых слова
  различаются. Например, расстояние между словами МАМА и ПАПА или
  МЫШКА и КОШКА равно двум).

--------------------------------------------------------------------------------
Вариант 10
  Дан произвольный текст. Напечатать в алфавитном порядке все буквы, которые
  входят в этот текст по одному разу.

--------------------------------------------------------------------------------
Вариант 11
  Распечатать введенное предложение, удалив из него слова, которые состоят
  менее чем из трех букв.

--------------------------------------------------------------------------------
Вариант 12
  Зашифровать текст следующим образом: записать его в матрицу по стракам, а
  затем переписать по спирали от центра. Прочесть зашифрованный текст.

--------------------------------------------------------------------------------
Вариант 13
  Из введенного текста распечатать все слова наименьшей длины.

--------------------------------------------------------------------------------
Вариант 14
  Распечатать введенную строку, удалив из нее слова с нечетными номерами и
  перевернув слова с четными номерами. Например, из строки
    во что бы то ни стало
  должно получиться
    отч от олатс

--------------------------------------------------------------------------------
Вариант 15
  Распечатать введенную строку, исключив из нее те символы, которые находятся
  между скобками '(' ')'. Сами скобки не удалять. Если хотя бы одной скобки
  нет - сообщить об этом.

--------------------------------------------------------------------------------
Вариант 16
  Ввести строку, в которую могут входить только цифры и буквы. Распечатать те
  группы букв, в которых буква А встречается не менее двух раз.
  (Группа букв - это последовательность букв, обрамленная цифрами).

--------------------------------------------------------------------------------
Вариант 17
  Составить частотный словарь вводимого текста. Распечатать его по алфавиту,
  а справа от каждого слова - частоту, с которой оно встретилось.

--------------------------------------------------------------------------------
Вариант 18
  Ввести произвольный текст. Вычислить среднее число слов в предложении и
  среднюю длину предложения.

--------------------------------------------------------------------------------
Вариант 19
  Распечатать, начиная с последнего, перевернутые слова введенного предложения.

--------------------------------------------------------------------------------
Вариант 20
  Во введенном тексте указать слово, в котором доля гласных (а, е, о)
  максимальна.
  
--------------------------------------------------------------------------------
