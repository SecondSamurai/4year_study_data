
                Линейные списки, стек, очередь.

  Список - это набор записей, каждая из которых имеет поле данных и
указатель (ссылку) на следующую запись в списке. Та в свою очередь,
тоже содержит поле данных и ссылку на продолжение списка. Последний
элемент списка (хвост) содержит значение ссылки на Nil. Ссылка на
следующий элемент списка содержит адрес первого байта области памяти,
содержащей следующий элемент списка.
  Созданные списки можно дополнять новыми элементами путем вставки их
в начало, конец или середину списка.
┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
│начало├───>│данные│ ┌─>│данные│ ┌─>│данные│ ┌─>Nil
└──────┘    ├──────┤ │  ├──────┤ │  ├──────┤ │
            │след. ├─┘  │след. ├─┘  │след. ├─┘
            └──────┘    └──────┘    └──────┘
{Рисунок списка}.
  В зависимости от способа доступа к элементам списка выделяют два
основных типа линейных списков: стек и очередь.
  Стек - это список с одной точкой доступа к элементам, которая называется
вершиной стека. Элементы добавляются и исключаются через вершину
стеку. (аналог стека - детская игрушка "пирамида", магазин автомата).
 ┌──────┐
 │ top  ├─┐
 └──────┘ │
 ┌──────┐ │
 │данные│<┘
 ├──────┤
 │след. ├─┐
 └──────┘ │
 ┌──────┐ │
 │данные│<┘
 ├──────┤
 │след. ├─┐
 └──────┘ │
    Nil  <┘
{Рисунок стека}.
  Стек - список, образующийся по правилу "первым пришел - последним ушел",
т.е. элемент, помещенный в стек первым, будет извлечен оттуда последним.


                       Алгоритм создания стека.

  1) В разделе описания типов описываем тип ссылку на элемент стека и
структуру самого элемента,
Type
   Ukaz =^ stek; {объявляем указатель на структуру данных}
   Stek = Record
           name: String[20];     {поле данных, их может быть несколько}
           next: Ukaz;           {ссылка на следующий элемент стека}
          End;

  2) Объявляем ссылку top типа Ukaz, который будет указывать на вершину
стека. Вначале, когда стек пуст, top указывает на Nil.
 top := Nil;
  ┌─top
  │
  └>Nil
  3) Добавим в стек первый элемент.
     а) Для чего выделяем блок памяти, необходимый для хранения элемента
        стека. Ссылка P будет указывать на первый байт этого блока памяти.
 New(P);
  ┌─P
  │ ┌──────┐
  └>│данные│
    ├──────┤    ┌─top
    │ Next │    │
    └──────┘    └>Nil
     б) Записываем в область данных элемента стека конкретные значения,
        например, 123.
  P^.Name := '123';
  ┌─P
  │ ┌──────┐
  └>│ 123  │
    ├──────┤    ┌─top
    │ Next │    │
    └──────┘    └>Nil
     в) Ссылка на следующий элемент стека будет указывать на вершину
        стека, но так как стек пока еще пуст, она будет указывать на
        Nil.
  P^.Next := top;
  ┌─P
  │ ┌──────┐
  └>│ 123  │
    ├──────┤    ┌─top
    │ Next ├─┐  │
    └──────┘ └─>└>Nil
     г) Поскольку в стек добавлен один элемент, то он и будет вершиной
        стека. Следовательно:
  top := P;
P ┌─top
│ │ ┌──────┐
└>└>│ 123  │
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil
  4) Добавим в стек еще один элемент.
     а) Для чего выделяем блок памяти, необходимый для хранения элемента
        стека. Ссылка P будет указывать на первый байт этого блока памяти.
 New(P);
  ┌─P
  │ ┌──────┐
  └>│данные│
    ├──────┤
    │ Next │    ┌─top
    └──────┘    │ ┌──────┐
                └>│ 123  │
                  ├──────┤
                  │ Next ├─┐
                  └──────┘ └─>Nil
     б) Записываем в область данных нового элемента стека конкретные
        значения, например, 444.
  P^.Name := '444';
  ┌─P
  │ ┌──────┐
  └>│ 444  │
    ├──────┤
    │ Next │    ┌─top
    └──────┘    │ ┌──────┐
                └>│ 123  │
                  ├──────┤
                  │ Next ├─┐
                  └──────┘ └─>Nil
     в) Ссылка на следующий элемент стека будет указывать на вершину
        стека, то есть на единственный элемент этого стека.
  P^.Next := top;
  ┌─P
  │ ┌──────┐
  └>│ 444  │
    ├──────┤
    │ Next ├─┐  ┌─top
    └──────┘ │  │ ┌──────┐
             └─>└>│ 123  │
                  ├──────┤
                  │ Next ├─┐
                  └──────┘ └─>Nil
     г) Поскольку в стек добавлен еще один элемент, то он и будет вершиной
        стека. Следовательно:
  top := P;
P ┌─top
│ │ ┌──────┐
└>└>│ 444  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 123  │
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil



                         Алгоритм просмотра стека

    Достаточно часто необходимо просмотреть данные, находящиеся в стеке,
для печати, каких-либо подсчетов или поисков. Рассмотрим пример: пусть в
стеке находится три элемента:
  ┌─top
  │ ┌──────┐
  └>│ 517  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 444  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 123  │
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil
   Для прохода по стеку будем использовать ссылку Р, которая в начале
просмотра указывает на вершину стека, то есть:
 P := top;
  ┌─top
  │ ┌──────┐
  └>│ 517  │<───P
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 444  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 123  │
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil
   В этот момент нам доступны данные элемента в вершине стека, мы можем их,
например, распечатать:
 WriteLn(P^.Name);   {на экране 517}
   Для того, чтобы переместиться на следующий элемент, необходимо выполнить
следующую операцию:
 P := P^.Next;
   Теперь ссылка P указывает на второй сверху элемент стека:
  ┌─top
  │ ┌──────┐
  └>│ 517  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 444  │<───P
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 123  │
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil

   Теперь нам доступны данные этого элемента стека, мы можем их,
распечатать:
 WriteLn(P^.Name);   {на экране 444}
   Для перемещения следующий элемент снова выполняем операцию:
 P := P^.Next;
   Теперь ссылка P указывает на третий сверху элемент стека:
  ┌─top
  │ ┌──────┐
  └>│ 517  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 444  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 123  │<───P
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil
   Печатаем:
  WriteLn(P^.Name);   {на экране 123}
   Последовательность этих действий выполняется пока P не станет равным
Nil, то есть мы достигли конца стека.
   Просмотр стека конечно удобнее выполнять в цикле:
  P := top;             {начинаем с вершины стека}
  While P <> Nil do     {просматриваем пока не достигли конца}
    begin
      WriteLn(P^.Name);  {печатаем данные}
      P := P^.Next;      {смещаемся на следующий элемент}
    end;


                         Удаление из стека

    Если мы работаем со стеком, то удалять элементы мы можем только из
вершины стека.
  ┌─top
  │ ┌──────┐
  └>│ 517  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 444  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 123  │
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil
  1) В ссылку Р заполнить адрес вершины стека:
  P := top;
  ┌─top
  │ ┌──────┐
  └>│ 517  │<───P
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 444  │
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 123  │
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil
  2) Указатель вершины стека смещаем на следующий от вершины элемент:
  top := top^.Next;
         ┌──────┐
         │ 517  │<───P
         ├──────┤
       ┌─┤ Next │
       │ └──────┘
       │ ┌──────┐
top───>└>│ 444  │
         ├──────┤
       ┌─┤ Next │
       │ └──────┘
       │ ┌──────┐
       └>│ 123  │
         ├──────┤
         │ Next ├─┐
         └──────┘ └─>Nil
   3) Освобождаем блок памяти, занятый элементом в вершине стека, на
который теперь указывает ссылка Р:
   Dispose(P);
  ┌─top
  │ ┌──────┐
  └>│ 444  │<───P
    ├──────┤
  ┌─┤ Next │
  │ └──────┘
  │ ┌──────┐
  └>│ 123  │
    ├──────┤
    │ Next ├─┐
    └──────┘ └─>Nil

Ниже приводится пример программы работы со стеком.

Program MyStek;
Uses Crt;
Type
   Ukaz =^ stek; {объявляем указатель на структуру данных}
   Stek = Record
           name: String[20];
           next: Ukaz;
          End;
Var
  top, P : Ukaz;
  Key : Char;

Procedure AddStek;
Var
 b : Boolean;
 N : String[20];
begin
 b := True;
 WriteLn('Для конца ввода элементов стека наберите слово "конец"');
 While b do
  begin
    Write('Введите элемент: ');
    ReadLn(N);
    If N = 'конец' Then
      b := False
    Else
      begin
        New(P);
        P^.Name := N;
        P^.Next := top;
        top := P;
      end;
  end;
end;

Procedure PrintStek;
begin
  If top = Nil Then
    WriteLn('Стек пуст')
  Else
    begin
      P := top;
      WriteLn('Состояние стека:');
      While P <> Nil do
        begin
          WriteLn(P^.Name);
          P := P^.Next;
        end;
    end;
  ReadLn;
end;

Procedure DelStek;
begin
  P := top;
  If P = Nil Then
    WriteLn('Стек пуст')
  Else
    begin
      top := top^.Next;
      Dispose(P);
    end;
end;

begin
  TextBackGround(Blue);
  top := Nil;
  Key := '1';
  While Key <> '4' do
   begin
     ClrScr;
     WriteLn('Выберите операцию:');
     WriteLn('1. Добавление в стек');
     WriteLn('2. Просмотр стека');
     WriteLn('3. Удаление из вершины стека');
     WriteLn('4. Выход из программы');
     Write('Ваш выбор: ');
     ReadLn(Key);
     Case Key Of
       '1': AddStek;
       '2': PrintStek;
       '3': DelStek;
     end;
   end;
end.
