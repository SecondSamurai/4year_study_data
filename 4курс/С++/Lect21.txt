                             Рекурсия

  Внутри тела подпрограммы (процедуры или функции) возможен вызов самой
этой подпрограммы. Процедуры или функции, использующие вызовы "самих себя",
называются рекурсивными. Рекурсия достаточно широко применяется в
программировании, что объясняется рекурсивной природой многих математических
алгоритмов. В качестве примера рассмотрим алгоритм вычисления факториала
от неотрицательного целого числа.

  0! = 1
  1! = 1
  2! = 1 * 2
  ...
  N! = 1 * 2 * ... * (N-1) * N

  Алгоритм основан на очевидном соотношении:

  N! = (N-1)! * N,

  что позволяет для вычисления факториала использовать результат точно
такого же вычисления для предыдущего числа.
  Обратите внимание, что рекурсивной процедуре или функции обязательно
должно присутствовать условие прекращение рекурсии.

  Function Fact(N : Word) : LongInt;
  begin
    If N = 0 Then
       Fact := 1                {условие прекращения рекурсии}
    Else
       Fact := N * Fact(N-1);   {рекурсивный вызов}
  end;

  Рекурсивная форма организации алгоритма обычно выглядит изящнее итерационной
и дает более компактный текст программы, но при выполнении, как правило,
медленнее и может вызвать переполнение стека (при каждом входе в подпрограмму
ее локальные переменные размещаются в особым образом организованной области
памяти, называемой программным стеком).


                  Косвенная рекурсия и опережающее описание

  Рекурсия может быть косвенной, когда процедура A вызывает процедуру B, а
та, в свою очередь, вызывает снова A. Например:

  Procedure A(i : Byte);
  begin
    {...}
    B(i);
    {...}
  end;

  Procedure B(j : Byte);
  begin
    {...}
    A(j);
    {...}
  end;

  Если строго следовать правилу, согласно которому каждая подпрограмма
перед вызовом должна быть описана, то приведенную выше конструкцию
использовать нельзя. Для того, чтобы такого рода вызовы стали возможны,
вводится ОПЕРЕЖАЮЩЕЕ ОПИСАНИЕ:

  Procedure B(j : Byte); Forward;

  Procedure A(i : Byte);
  begin
    {...}
    B(i);
    {...}
  end;

  Procedure B;
  begin
    {...}
    A(j);
    {...}
  end;

  Как видно из примера, опережающее описание заключается в том, что
объявляется лишь заголовок процедуры B, а ее тело заменяется стандартной
директивой Forward. Теперь в процедуре A можно использовать обращение к
процедуре B, так как она уже описана, точнее, известны ее формальные
параметры, и компилятор может правильным образом организовать ее вызов.

  !!! Обратите внимание, при опережающем описании тело процедуры B начинается
  заголовком, в котором уже не указываются описанные ранее формальные
  параметры.

