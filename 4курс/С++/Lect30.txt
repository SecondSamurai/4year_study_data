                        Работа с очередью

  Очередь - это список, образующийся по правилу "первым пришел - первым ушел",
т.е. элемент, помещенный в очередь первым, будет извлечен оттуда первым же.
При добавлении в очередь элемент добавляется в конец очереди, при удалении
из очереди элемент извлекается из начала очереди. Поэтому для работы с
очередью необходимо два указателя: на первый элемент очереди First и на
последний Last.
 ┌──────┐                 ┌──────┐
 │начало├┐                │конец ├┐
 └──────┘│                └──────┘│
         │  ┌──────┐    ┌──────┐  └>┌──────┐
         └─>│данные│ ┌─>│данные│ ┌─>│данные│ ┌─>Nil
            ├──────┤ │  ├──────┤ │  ├──────┤ │
            │след. ├─┘  │след. ├─┘  │след. ├─┘
            └──────┘    └──────┘    └──────┘


                       Алгоритм создания очереди.

  1) В разделе описания типов описываем тип ссылку на элемент очереди и
структуру самого элемента,
Type
   Ukaz =^Och; {объявляем указатель на структуру данных}
   Och = Record
           name: String[20];     {поле данных, их может быть несколько}
           next: Ukaz;           {ссылка на следующий элемент очереди}
          End;

  2) Объявляем ссылки First и Last Ukaz, которые будут указывать на начало
и конец очереди соответственно. Вначале, когда очередь пуста, First и Last
указывают на Nil.
 First := Nil;
 Last := Nil;
First─┐     ┌─Last
      │     │
      └>Nil<┘
  3) Добавим в очередь первый элемент.
     а) Для чего выделяем блок памяти, необходимый для хранения элемента
        очереди. Ссылка P будет указывать на первый байт этого блока памяти.
 New(P);
  ┌─P
  │ ┌──────┐
  └>│данные│
    ├──────┤   First─┐     ┌─Last
    │ Next │         │     │
    └──────┘         └>Nil<┘
     б) Записываем в область данных элемента очереди конкретные значения,
        например, Иван.
  P^.Name := 'Иван';
  ┌─P
  │ ┌──────┐
  └>│ Иван │
    ├──────┤   First─┐     ┌─Last
    │ Next │         │     │
    └──────┘         └>Nil<┘
     в) Так как мы можем добавлять только в конец очереди, то ссылка на
        следующий элемент очереди будет указывать на Nil.
  P^.Next := Nil;
  ┌─P
  │ ┌──────┐
  └>│ Иван │
    ├──────┤ First─┐     ┌─Last
    │ Next ├─┐     │     │
    └──────┘ └────>└>Nil<┘
     г) Так как мы добавляем в очередь первый элемент, то есть до этого
        очередь была пуста First=Nil и Last=Nil, то указатели First и Last
        будут указывать на один и тот же элемент, который будет является
        одновременно началом и концом очереди.
 If (First=Nil) And (Last=Nil) Then
  begin
   First := P;
   Last := P;
  end;
First┐ ┌─P        ┌Last
     │ │ ┌──────┐ │
     └>└>│ Иван │<┘
         ├──────┤
         │ Next ├─┐
         └──────┘ └─>Nil
  4) Добавим в очередь еще один элемент.
     а) Для чего выделяем блок памяти, необходимый для хранения элемента
        очереди. Ссылка P будет указывать на первый байт этого блока памяти.
 New(P);
First┐ ┌─P        ┌Last   ┌─P
     │ │ ┌──────┐ │       │ ┌──────┐
     └>└>│ Иван │<┘       └>│данные│
         ├──────┤           ├──────┤
         │ Next ├─┐         │ Next │
         └──────┘ └─>Nil    └──────┘

     б) Записываем в область данных нового элемента стека конкретные
        значения, например, Стас.
  P^.Name := 'Стас';
First┐ ┌─P        ┌Last   ┌─P
     │ │ ┌──────┐ │       │ ┌──────┐
     └>└>│ Иван │<┘       └>│ Стас │
         ├──────┤           ├──────┤
         │ Next ├─┐         │ Next │
         └──────┘ └─>Nil    └──────┘
     в) Данные добавляются только в конец очереди. Поэтому необходимо
        связать последний элемент очереди с новым элементом:
  Last^.Next := P;
First┐ ┌─P        ┌Last   ┌─P
     │ │ ┌──────┐ │       │ ┌──────┐
     └>└>│ Иван │<┘    ┌─>└>│ Стас │
         ├──────┤      │    ├──────┤
         │ Next ├──────┘    │ Next │
         └──────┘           └──────┘
     г) Поскольку в очередь добавлен еще один элемент, то он и будет концом
        очереди. Следовательно:
  Last := P;
  Last.Next := Nil;
First┐                  ┌─P        ┌Last
     │ ┌──────┐         │ ┌──────┐ │
     └>│ Иван │      ┌─>└>│ Стас │<┘
       ├──────┤      │    ├──────┤
       │ Next ├──────┘    │ Next ├─┐
       └──────┘           └──────┘ └─>Nil


                         Алгоритм просмотра очереди

    Достаточно часто необходимо просмотреть данные, находящиеся в очереди,
для печати, каких-либо подсчетов или поисков. Рассмотрим пример: пусть в
очереди находится три элемента:
First┐                                    ┌Last
     │ ┌──────┐     ┌──────┐     ┌──────┐ │
     └>│ Иван │  ┌─>│ Стас │  ┌─>│ Петр │<┘
       ├──────┤  │  ├──────┤  │  ├──────┤
       │ Next ├──┘  │ Next ├──┘  │ Next ├─┐
       └──────┘     └──────┘     └──────┘ └─>Nil
   Для прохода по очереди будем использовать ссылку Р, которая в начале
просмотра указывает на началоу очереди, то есть:
 P := First;
First┐          ┌P                        ┌Last
     │ ┌──────┐ │   ┌──────┐     ┌──────┐ │
     └>│ Иван │<┘┌─>│ Стас │  ┌─>│ Петр │<┘
       ├──────┤  │  ├──────┤  │  ├──────┤
       │ Next ├──┘  │ Next ├──┘  │ Next ├─┐
       └──────┘     └──────┘     └──────┘ └─>Nil
   В этот момент нам доступны данные элемента в начале очереди, мы можем их,
например, распечатать:
 WriteLn(P^.Name);   {на экране Иван}
   Для того, чтобы переместиться на следующий элемент, необходимо выполнить
следующую операцию:
 P := P^.Next;
   Теперь ссылка P указывает на второй элемент очереди:
First┐                       ┌P           ┌Last
     │ ┌──────┐     ┌──────┐ │   ┌──────┐ │
     └>│ Иван │  ┌─>│ Стас │<┘┌─>│ Петр │<┘
       ├──────┤  │  ├──────┤  │  ├──────┤
       │ Next ├──┘  │ Next ├──┘  │ Next ├─┐
       └──────┘     └──────┘     └──────┘ └─>Nil
   Теперь нам доступны данные этого элемента очереди, мы можем их,
распечатать:
 WriteLn(P^.Name);   {на экране Стас}
   Для перемещения следующий элемент снова выполняем операцию:
 P := P^.Next;
   Теперь ссылка P указывает на третий элемент очереди:
First┐                                    ┌Last ┌P
     │ ┌──────┐     ┌──────┐     ┌──────┐ │     │
     └>│ Иван │  ┌─>│ Стас │  ┌─>│ Петр │<┘<────┘
       ├──────┤  │  ├──────┤  │  ├──────┤
       │ Next ├──┘  │ Next ├──┘  │ Next ├─┐
       └──────┘     └──────┘     └──────┘ └─>Nil
   Печатаем:
  WriteLn(P^.Name);   {на экране Петр}
   Последовательность этих действий выполняется пока P не станет равным
Last, то есть мы достигли конца очереди.
   Просмотр очереди конечно удобнее выполнять в цикле:
P := First;           {начинаем с начала очереди}
Priznak := False;     {признак того, что достигнут конец очереди}
While Not Priznak do  {просматриваем пока не достигли конца}
 begin
  WriteLn(P^.Name);   {печатаем данные}
  If P = Last Then Priznak := True{если Р - последний элемент, конец просмотра}
              Else P := P^.Next;  {иначе - смещаемся на следующий элемент}
 end;

                         Удаление из очереди

    Если мы работаем с очередью, то удалять элементы мы можем только из
начала очереди.
First┐                                    ┌Last
     │ ┌──────┐     ┌──────┐     ┌──────┐ │
     └>│ Иван │  ┌─>│ Стас │  ┌─>│ Петр │<┘
       ├──────┤  │  ├──────┤  │  ├──────┤
       │ Next ├──┘  │ Next ├──┘  │ Next ├─┐
       └──────┘     └──────┘     └──────┘ └─>Nil
  1) В ссылку Р записать адрес начала очереди:
  P := First;
First┐          ┌P                        ┌Last
     │ ┌──────┐ │   ┌──────┐     ┌──────┐ │
     └>│ Иван │<┘┌─>│ Стас │  ┌─>│ Петр │<┘
       ├──────┤  │  ├──────┤  │  ├──────┤
       │ Next ├──┘  │ Next ├──┘  │ Next ├─┐
       └──────┘     └──────┘     └──────┘ └─>Nil
  2) Указатель начало очереди смещаем на следующий от начала элемент:
  First := First^.Next;
                ┌P┌First                  ┌Last
       ┌──────┐ │ └>┌──────┐     ┌──────┐ │
       │ Иван │<┘┌─>│ Стас │  ┌─>│ Петр │<┘
       ├──────┤  │  ├──────┤  │  ├──────┤
       │ Next ├──┘  │ Next ├──┘  │ Next ├─┐
       └──────┘     └──────┘     └──────┘ └─>Nil
  3) Освобождаем блок памяти, занятый элементом в начале очереди, на
который теперь указывает ссылка Р:
   Dispose(P);
First┐                       ┌Last
     │ ┌──────┐     ┌──────┐ │
     └>│ Стас │  ┌─>│ Петр │<┘
       ├──────┤  │  ├──────┤
       │ Next ├──┘  │ Next ├─┐
       └──────┘     └──────┘ └─>Nil
Ниже приводится пример программы работы с очередью.

Program MyOch;
Uses Crt;
Type
   Ukaz =^ Och; {объявляем указатель на структуру данных}
   Och = Record
           name: String[20];
           next: Ukaz;
          End;
Var
  First, Last, P : Ukaz;
  Key : Char;

Procedure AddOch;
begin
  New(P);                                {выделяем память}
  Write('Введите элемент: ');            {записываем данные}
  ReadLn(P^.Name);
  If (First = Nil) And (Last = Nil) Then {если очередь была пуста...}
    begin
      First := P;                  {этот элемент становится одновременно}
      Last := P;                   {первым и последним элементом очереди}
    end
  Else                             {иначе...}
    begin
      Last^.Next := P;             {этот элемент становится последним}
      Last := P;
    end;
  Last^.Next := Nil;               {последний элемент указывает на Nil}
end;

Procedure PrintOch;
Var
  Priznak : Boolean;
begin
  If (First = Nil) And (Last = Nil) Then   {если очередь пуста...}
     WriteLn('Очередь пуста')
  Else                                     {иначе...}
     begin
       P := First;           {начинаем с начала очереди}
       Priznak := False;     {признак того, что достигнут конец очереди}
       While Not Priznak do  {просматриваем пока не достигли конца}
        begin
         Write(P^.Name, '  ');   {печатаем данные}
         If P = Last Then Priznak := True{если Р - последний элемент, конец просмотра}
                     Else P := P^.Next;  {иначе - смещаемся на следующий элемент}
        end;
     end;
  ReadLn;
end;

Procedure DelOch;
begin
  P := First;                           {становимся на первый элемент}
  If (First = Nil) And (Last = Nil) Then{если очередь пуста...}
    begin
      WriteLn('Очередь пуста');
      ReadLn;
    end
  Else                                  {иначе...}
    begin
      If First = Last Then              {если в очереди только один элемент}
        begin
          First := Nil;                 {то после удаления очередь пуста}
          Last := Nil;
        end
      Else                              {если больше одного элемента}
        First := First^.Next;           {первым будет второй элемент
                                         в очереди}
      Dispose(P);                       {удаляем элемент Р}
    end;
end;

begin
  TextBackGround(Blue);
  First := Nil;
  Last := Nil;
  Key := '1';
  While Key <> '4' do
   begin
     ClrScr;
     WriteLn('Выберите операцию:');
     WriteLn('1. Добавление в очередь');
     WriteLn('2. Просмотр очереди');
     WriteLn('3. Удаление из начала очереди');
     WriteLn('4. Выход из программы');
     Write('Ваш выбор: ');
     ReadLn(Key);
     Case Key Of
       '1': AddOch;
       '2': PrintOch;
       '3': DelOch;
     end;
   end;
end.
